package atomicstryker.minions.common.pathfinding;import java.util.ArrayList;import java.util.Iterator;import java.util.PriorityQueue;import net.minecraft.world.World;/** * Runnable worker class for finding an AstarPath * is prone to crashes when no path can be found. *  * @author AtomicStryker */public class AStarWorker extends Thread{    /**     * How many cubes will the worker check for a path before giving up     */    private int maxCheckedCubes = 1000;    	private AStarPath boss;	private boolean isRunning = false;		public final ArrayList<AStarNode> closedNodes;	private AStarNode startNode;	private AStarNode targetNode;	private boolean allowDropping;	private World worldObj;	private long startingTime;	private int checkedCubes = 0;		private final PriorityQueue<AStarNode> queue;		public AStarWorker(AStarPath creator)	{		boss = creator;		closedNodes = new ArrayList<AStarNode>();		queue = new PriorityQueue<AStarNode>(maxCheckedCubes/3);	}	@Override	public void run()	{		if (isRunning) return;		isRunning = true;				ArrayList result = null;		result = getPath(startNode, targetNode, allowDropping);		if (result == null)		{			boss.onNoPathAvailable();		}		else		{			boss.onFoundPath(result);		}	}		/**	 * Setup some pointers for the seaching run	 * @param winput World to search in	 * @param start Starting Node	 * @param end Target Node of the Path	 * @param mode true if dropping more than 1 Block is allowed	 */	public void setup(World winput, AStarNode start, AStarNode end, boolean mode)	{		worldObj = winput;		startNode = start;		targetNode = end;		allowDropping = mode;		//System.out.println("Start Node: "+start.x+", "+start.y+", "+start.z);		//System.out.println("Target Node: "+end.x+", "+end.y+", "+end.z);	}		/**	 * Reset the Worker, ready it for a new search	 */	public void resetSearch()	{		closedNodes.clear();		checkedCubes = 0;		queue.clear();	}	public ArrayList<AStarNode> getPath(AStarNode start, AStarNode end, boolean searchMode)	{		queue.offer(start);		startingTime = System.currentTimeMillis();		targetNode = end;		AStarNode current = start;		while(!current.equals(end))		{			closedNodes.add(queue.poll());						checkPossibleLadder(current);			getNextCandidates(current, searchMode);			if (queue.isEmpty() || Thread.interrupted() || checkedCubes >= maxCheckedCubes)			{				//System.out.println("Path search aborted, checkedCubes: "+checkedCubes+", interrupted: "+Thread.interrupted());				return null;			}			current = queue.peek();			checkedCubes++;			//System.out.println("current Node is now "+current.x+", "+current.y+", "+current.z+" of cost "+current.getF());		}		ArrayList<AStarNode> foundpath = new ArrayList<AStarNode>();		foundpath.add(current);		while (current != start)		{			foundpath.add(current.parent);			current = current.parent;		}				//System.out.println("Path search success, visited "+checkedCubes+" Nodes, pathpoints: "+foundpath.size()+", abs. distance "+AStarStatic.getDistanceBetweenNodes(start, end));		return foundpath;	}	private void addToBinaryHeap(AStarNode input)	{	    queue.offer(input);	}		/**	 * Checks a Node for being a Ladder and adds it's up- and downward Blocks to	 * the Heap if it is.	 * @param node Node being checked	 */	private void checkPossibleLadder(AStarNode node)	{		int x = node.x;		int y = node.y;		int z = node.z;		if (AStarStatic.isLadder(worldObj, worldObj.getBlockId(x, y, z), x, y, z))		{			AStarNode ladder = null;			if (AStarStatic.isLadder(worldObj, worldObj.getBlockId(x, y+1, z), x, y+1, z));			{				ladder = new AStarNode(x, y+1, z, node.getG()+2, node, targetNode);				if (!tryToUpdateExistingHeapNode(node, ladder))				{					addToBinaryHeap(ladder);				}			}			if (AStarStatic.isLadder(worldObj, worldObj.getBlockId(x, y-1, z), x, y-1, z));			{				ladder = new AStarNode(x, y-1, z, node.getG()+2, node, targetNode);				if (!tryToUpdateExistingHeapNode(node, ladder))				{					addToBinaryHeap(ladder);				}			}		}	}		/**	 * Expands a Node to find new Candidates	 * @param parent Node being expanded	 * @param droppingAllowed if true, will consider Blocks around more than 1 lower	 */	public void getNextCandidates(AStarNode parent, boolean droppingAllowed)	{		int x = parent.x;		int y = parent.y;		int z = parent.z;		int[][] c = droppingAllowed ? AStarStatic.candidates_allowdrops : AStarStatic.candidates;		AStarNode check;		for (int i = 0; i < c.length; i++)		{			check = new AStarNode(x+c[i][0], y+c[i][1], z+c[i][2], parent.getG()+c[i][3], parent, targetNode);			int index = closedNodes.indexOf(check);			if (index >= 0)			{			    AStarNode toUpdate = closedNodes.get(index);			    toUpdate.updateDistance(check.getG()+getCostNodeToNode(toUpdate, check), parent);			}			else if (!tryToUpdateExistingHeapNode(parent, check))			{				if (AStarStatic.isViable(worldObj, check, c[i][1]))				{					addToBinaryHeap(check);				}			}		}	}		/**	 * Calculates linear movement cost between two AStarNodes	 * @param a Node	 * @param b Node	 * @return 1 for every adjacent Block (no diagonals!) you have to traverse to get from a to b	 */	private int getCostNodeToNode(AStarNode a, AStarNode b)	{	    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y) + Math.abs(a.z - b.z);	}		/**	 * Searches the Heap for an existing equal Node and updates it's distance and	 * parent Node fields if it finds one.	 * 	 * @param parent Parent Node to update the field with	 * @param checkedOne Node to find an equal of	 * @return true if a Node was found, false otherwise	 */	private boolean tryToUpdateExistingHeapNode(AStarNode parent, AStarNode checkedOne)	{	    Iterator<AStarNode> iter = queue.iterator();	    AStarNode itNode;	    while (iter.hasNext())	    {	        itNode = iter.next();	        if (itNode.equals(checkedOne))	        {	            itNode.updateDistance(checkedOne.getG(), parent);	            return true;	        }	    }	    	    return false;	}}